"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .httpmetadata import HTTPMetadata, HTTPMetadataTypedDict
from apideck_unify.types import BaseModel
from apideck_unify.utils import FieldMetadata, HeaderMetadata, RequestMetadata
import httpx
import io
import pydantic
from typing import Any, Dict, IO, List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypedDict


class ProxyPatchProxyGlobalsTypedDict(TypedDict):
    consumer_id: NotRequired[str]
    r"""ID of the consumer which you want to get or push data from"""
    app_id: NotRequired[str]
    r"""The ID of your Unify application"""


class ProxyPatchProxyGlobals(BaseModel):
    consumer_id: Annotated[
        Optional[str],
        pydantic.Field(alias="x-apideck-consumer-id"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""ID of the consumer which you want to get or push data from"""

    app_id: Annotated[
        Optional[str],
        pydantic.Field(alias="x-apideck-app-id"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The ID of your Unify application"""


class ProxyPatchProxyRequestBody3TypedDict(TypedDict):
    pass


class ProxyPatchProxyRequestBody3(BaseModel):
    pass


class ProxyPatchProxyRequestBody1TypedDict(TypedDict):
    pass


class ProxyPatchProxyRequestBody1(BaseModel):
    pass


class ProxyPatchProxyRequestTypedDict(TypedDict):
    service_id: str
    r"""Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API."""
    downstream_url: str
    r"""Downstream URL"""
    consumer_id: NotRequired[str]
    r"""ID of the consumer which you want to get or push data from"""
    app_id: NotRequired[str]
    r"""The ID of your Unify application"""
    unified_api: NotRequired[str]
    r"""Specify which unified API to use for the connection lookup. Required for multi-API connectors (e.g., Workday) to ensure the correct credentials are used."""
    downstream_authorization: NotRequired[str]
    r"""Downstream authorization header. This will skip the Vault token injection."""
    request_body: NotRequired[Union[bytes, IO[bytes], io.BufferedReader]]
    r"""Depending on the verb/method of the request this will contain the request body you want to POST/PATCH/PUT."""


class ProxyPatchProxyRequest(BaseModel):
    service_id: Annotated[
        str,
        pydantic.Field(alias="x-apideck-service-id"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ]
    r"""Provide the service id you want to call (e.g., pipedrive). Only needed when a consumer has activated multiple integrations for a Unified API."""

    downstream_url: Annotated[
        str,
        pydantic.Field(alias="x-apideck-downstream-url"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ]
    r"""Downstream URL"""

    consumer_id: Annotated[
        Optional[str],
        pydantic.Field(alias="x-apideck-consumer-id"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""ID of the consumer which you want to get or push data from"""

    app_id: Annotated[
        Optional[str],
        pydantic.Field(alias="x-apideck-app-id"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""The ID of your Unify application"""

    unified_api: Annotated[
        Optional[str],
        pydantic.Field(alias="x-apideck-unified-api"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""Specify which unified API to use for the connection lookup. Required for multi-API connectors (e.g., Workday) to ensure the correct credentials are used."""

    downstream_authorization: Annotated[
        Optional[str],
        pydantic.Field(alias="x-apideck-downstream-authorization"),
        FieldMetadata(header=HeaderMetadata(style="simple", explode=False)),
    ] = None
    r"""Downstream authorization header. This will skip the Vault token injection."""

    request_body: Annotated[
        Optional[Union[bytes, IO[bytes], io.BufferedReader]],
        FieldMetadata(request=RequestMetadata(media_type="*/*")),
    ] = None
    r"""Depending on the verb/method of the request this will contain the request body you want to POST/PATCH/PUT."""


class ProxyPatchProxyResponseTypedDict(TypedDict):
    http_meta: HTTPMetadataTypedDict
    headers: Dict[str, List[str]]
    response_json: NotRequired[Dict[str, Any]]
    r"""Ok"""
    response_binary: NotRequired[httpx.Response]
    r"""Ok"""
    response_pdf: NotRequired[httpx.Response]
    r"""Ok"""
    response_xml: NotRequired[str]
    r"""Ok"""
    response_csv: NotRequired[str]
    r"""Ok"""
    response_text: NotRequired[str]
    r"""Ok"""
    error_json: NotRequired[Dict[str, Any]]
    r"""Proxy error"""
    error_xml: NotRequired[str]
    r"""Proxy error"""
    error_html: NotRequired[str]
    r"""Proxy error"""
    error_text: NotRequired[str]
    r"""Proxy error"""


class ProxyPatchProxyResponse(BaseModel):
    http_meta: Annotated[Optional[HTTPMetadata], pydantic.Field(exclude=True)] = None

    headers: Dict[str, List[str]]

    response_json: Optional[Dict[str, Any]] = None
    r"""Ok"""

    response_binary: Optional[httpx.Response] = None
    r"""Ok"""

    response_pdf: Optional[httpx.Response] = None
    r"""Ok"""

    response_xml: Optional[str] = None
    r"""Ok"""

    response_csv: Optional[str] = None
    r"""Ok"""

    response_text: Optional[str] = None
    r"""Ok"""

    error_json: Optional[Dict[str, Any]] = None
    r"""Proxy error"""

    error_xml: Optional[str] = None
    r"""Proxy error"""

    error_html: Optional[str] = None
    r"""Proxy error"""

    error_text: Optional[str] = None
    r"""Proxy error"""
